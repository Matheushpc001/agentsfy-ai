// Vers√£o 1.1 - For√ßando re-deploy para limpar cache
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.0.0";
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};
// Handler principal
async function handler(req) {
  // --- NOVO LOG DE DIAGN√ìSTICO ---
  console.log("‚úÖ‚úÖ‚úÖ DEPLOY V2 - JWT Desativado - INVOCADO ‚úÖ‚úÖ‚úÖ");
  console.log(`[${new Date().toISOString()}] üöÄ Webhook Handler INVOCADO. M√©todo: ${req.method}. URL: ${req.url}`);
  if (req.method === 'OPTIONS') {
    return new Response(null, {
      headers: corsHeaders
    });
  }
  try {
    const payload = await req.json();
    console.log('üì® Webhook payload received:', JSON.stringify(payload, null, 2));
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Supabase environment variables not configured');
    }
    const supabase = createClient(supabaseUrl, supabaseKey);
    const { event } = payload;
    console.log('üîç Processing webhook event:', event);
    switch(event){
      case 'connection.update':
      case 'CONNECTION_UPDATE':
        await handleConnectionUpdate(supabase, payload);
        break;
      case 'messages.upsert':
      case 'MESSAGES_UPSERT':
        await handleMessageUpsert(supabase, payload);
        break;
      case 'qrcode.updated':
      case 'QRCODE_UPDATED':
        await handleQRCodeUpdate(supabase, payload);
        break;
      default:
        console.log(`‚ÑπÔ∏è Evento n√£o tratado recebido: ${event}`);
    }
    return new Response(JSON.stringify({
      success: true,
      message: 'Webhook processed successfully'
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('‚ùå Webhook processing error:', error);
    return new Response(JSON.stringify({
      error: 'Webhook processing failed',
      details: error.message
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
}
// Inicia o servidor
console.log(`[${new Date().toISOString()}] üì¢ Servidor do Webhook est√° sendo inicializado e escutando...`);
// MODIFICA√á√ÉO APLICADA AQUI:
serve(handler, {
  verifyJWT: false,
  onListen: ({ port, hostname })=>{
    console.log(`üöÄ Webhook server listening on http://${hostname}:${port}`);
  }
});
// --- FUN√á√ïES AUXILIARES ---
async function handleConnectionUpdate(supabase, payload) {
  console.log('üîÑ Processing connection update:', payload);
  const instanceName = payload.instance;
  const connectionState = payload.data?.state || payload.data?.connectionStatus;
  if (!instanceName) {
    console.log('‚ö†Ô∏è No instance name found in connection update');
    return;
  }
  console.log('üì± Instance:', instanceName, 'New state:', connectionState);
  let newStatus = 'disconnected';
  switch(connectionState){
    case 'open':
    case 'connected':
      newStatus = 'connected';
      console.log('‚úÖ WhatsApp CONNECTED detected via webhook!');
      break;
    case 'connecting':
    case 'qr':
      newStatus = 'qr_ready';
      console.log('üîÑ WhatsApp waiting for QR scan');
      break;
    case 'close':
    case 'closed':
    case 'disconnected':
      newStatus = 'disconnected';
      console.log('‚ùå WhatsApp DISCONNECTED');
      break;
    default:
      console.log('‚ùì Unknown connection state:', connectionState);
      return;
  }
  const updateData = {
    status: newStatus,
    updated_at: new Date().toISOString()
  };
  if (newStatus === 'connected') {
    updateData.qr_code = null;
    updateData.qr_code_expires_at = null;
  }
  const { data, error } = await supabase.from('evolution_api_configs').update(updateData).eq('instance_name', instanceName).select();
  if (error) {
    console.error('‚ùå Error updating config status:', error);
    return;
  }
  if (data && data.length > 0) {
    console.log('‚úÖ Config updated successfully:', data[0].id, 'Status:', newStatus);
    if (newStatus === 'connected') {
      await notifyConnectionSuccess(supabase, data[0]);
    }
  } else {
    console.log('‚ö†Ô∏è No config found for instance:', instanceName);
  }
}
async function handleMessageUpsert(supabase: any, payload: any) {
  const instanceName = payload.instance;
  const messageData = payload.data;
  const remoteJid = messageData?.key?.remoteJid;

  // Ignorar mensagens de grupo e de status
  if (!remoteJid || remoteJid.endsWith('@g.us') || remoteJid.endsWith('@broadcast')) {
    console.log('üó£Ô∏è Mensagem de grupo ou status ignorada.');
    return;
  }
  
  // Ignorar mensagens sem conte√∫do relevante (ex: chamadas perdidas)
  if (!messageData.message) {
    console.log('‚ÑπÔ∏è Mensagem sem conte√∫do relevante ignorada.');
    return;
  }

  // --- BUSCAR CONFIGURA√á√ÉO DA INST√ÇNCIA E AGENTE DE IA ---
  const { data: config, error: configError } = await supabase
    .from('evolution_api_configs')
    .select('id, franchisee_id')
    .eq('instance_name', instanceName)
    .single();

  if (configError || !config) {
    console.error(`‚ùå Configura√ß√£o n√£o encontrada para a inst√¢ncia: ${instanceName}`, configError);
    return;
  }
  
  const { data: aiAgent, error: agentError } = await supabase
    .from('ai_whatsapp_agents')
    .select('id, openai_api_key')
    .eq('evolution_config_id', config.id)
    .eq('is_active', true)
    .single();

  if (agentError || !aiAgent?.openai_api_key) {
    console.log(`‚ÑπÔ∏è Nenhum agente de IA ativo com chave OpenAI para a inst√¢ncia: ${instanceName}`);
    // Poder√≠amos parar aqui ou continuar salvando a mensagem sem IA
  }
  
  // --- PROCESSAMENTO E TRANSCRI√á√ÉO DA MENSAGEM ---
  let messageContent = "[M√≠dia n√£o suportada]";
  let messageType = 'text';

  const isAudioMessage = !!messageData.message?.audioMessage;
  
  if (isAudioMessage) {
    messageType = 'audio';
    console.log('üé§ Mensagem de √°udio recebida. Tentando transcrever...');
    
    // VERIFICA SE A EVOLUTION API J√Å TRANSCRITOU (FALLBACK)
    if (messageData.message.speechToText) {
        console.log('‚úÖ Transcri√ß√£o encontrada no payload da Evolution API.');
        messageContent = messageData.message.speechToText;
    } 
    // SE N√ÉO, CHAMA NOSSA FUN√á√ÉO DE TRANSCRI√á√ÉO
    else if (aiAgent?.openai_api_key && messageData.message.audioMessage.url) {
      try {
        const { data: transcribeData, error: transcribeError } = await supabase.functions.invoke('openai-handler', {
          body: {
            action: 'transcribe',
            openaiApiKey: aiAgent.openai_api_key,
            audioUrl: messageData.message.audioMessage.url,
            mimetype: messageData.message.audioMessage.mimetype || 'audio/ogg'
          }
        });
        
        if (transcribeError) throw transcribeError;
        
        messageContent = transcribeData.transcribedText;
        console.log(`‚úÖ Transcri√ß√£o bem-sucedida: "${messageContent.substring(0, 50)}..."`);
        
      } catch (error) {
        // --- LOG DE ERRO APRIMORADO ---
        console.error('‚ùå Erro ao invocar a fun√ß√£o de transcri√ß√£o:', error);
        if (error.context && error.context.json) {
            const errorJson = await error.context.json();
            console.error('Detalhes do erro da fun√ß√£o openai-handler:', JSON.stringify(errorJson, null, 2));
        }
        // --- FIM DO APRIMORAMENTO ---
        messageContent = "[Erro ao transcrever √°udio]";
      }
    } else {
        console.warn('‚ö†Ô∏è N√£o foi poss√≠vel transcrever: Chave OpenAI ou URL do √°udio ausente.');
        messageContent = "[√Åudio recebido, transcri√ß√£o indispon√≠vel]";
    }
  } else {
    messageType = 'text';
    messageContent = messageData.message?.conversation || messageData.message?.extendedTextMessage?.text || "[Tipo de mensagem n√£o suportado]";
  }

  // --- SALVAR MENSAGEM E CONVERSA ---
  const contactNumber = remoteJid.split('@')[0];
  if (!contactNumber) return;

  const { data: conversation } = await supabase
    .from('whatsapp_conversations')
    .select('id')
    .eq('evolution_config_id', config.id)
    .eq('contact_number', contactNumber)
    .single();
    
  let conversationId = conversation?.id;

  if (!conversation) {
    const { data: newConversation, error: createConvError } = await supabase
      .from('whatsapp_conversations')
      .insert({ evolution_config_id: config.id, contact_number: contactNumber, contact_name: contactNumber })
      .select('id')
      .single();
      
    if (createConvError) {
      console.error('‚ùå Erro ao criar nova conversa:', createConvError);
      return;
    }
    conversationId = newConversation?.id;
  }
  
  if (!conversationId) {
    console.error('‚ùå ID da conversa n√£o p√¥de ser determinado.');
    return;
  }

  const { error: insertMsgError } = await supabase.from('whatsapp_messages').insert({
    conversation_id: conversationId,
    message_id: messageData.key?.id,
    content: messageContent,
    message_type: messageType,
    sender_type: messageData.key?.fromMe ? 'agent' : 'user',
    is_from_me: messageData.key?.fromMe || false,
  });

  if(insertMsgError) {
    console.error('‚ùå Erro ao salvar mensagem:', insertMsgError);
    return;
  }
  console.log(`‚úÖ Mensagem de ${contactNumber} salva com sucesso. Tipo: ${messageType}`);

  // --- ACIONAR RESPOSTA DA IA ---
  if (!messageData.key?.fromMe && messageContent && !messageContent.startsWith("[")) {
    console.log('‚û°Ô∏è Mensagem de usu√°rio recebida. Acionando verifica√ß√£o de auto-resposta da IA...');
    await checkAutoResponse(supabase, config.id, conversationId, messageContent);
  } else {
    console.log('‚û°Ô∏è Mensagem do agente ou sem conte√∫do v√°lido. Ignorando auto-resposta.');
  }
}



async function handleQRCodeUpdate(supabase, payload) {
  console.log('üì± Processing QR code update:', payload);
  const instanceName = payload.instance;
  const qrCode = payload.data?.qrcode || payload.data?.qr;
  if (!instanceName || !qrCode) {
    console.log('‚ö†Ô∏è Incomplete QR code data');
    return;
  }
  const { error } = await supabase.from('evolution_api_configs').update({
    qr_code: qrCode,
    qr_code_expires_at: new Date(Date.now() + 2 * 60 * 1000).toISOString(),
    status: 'qr_ready',
    updated_at: new Date().toISOString()
  }).eq('instance_name', instanceName);
  if (error) {
    console.error('‚ùå Error updating QR code:', error);
  } else {
    console.log('‚úÖ QR code updated successfully for:', instanceName);
  }
}
async function findOrCreateConversation(supabase, configId, contactNumber) {
  const { data: existing, error: findError } = await supabase.from('whatsapp_conversations').select('*').eq('evolution_config_id', configId).eq('contact_number', contactNumber).single();
  if (!findError && existing) {
    return existing;
  }
  const { data: newConversation, error: createError } = await supabase.from('whatsapp_conversations').insert([
    {
      evolution_config_id: configId,
      contact_number: contactNumber,
      contact_name: contactNumber,
      is_active: true,
      last_message_at: new Date().toISOString()
    }
  ]).select().single();
  if (createError) {
    console.error('‚ùå Error creating conversation:', createError);
    throw createError;
  }
  return newConversation;
}
async function checkAutoResponse(supabase: any, configId: string, conversationId: string, messageContent: string) {
  console.log('ü§ñ PASSO 1: Iniciando checkAutoResponse...');
  
  try {
    // Encontrar o agente de IA ativo para esta inst√¢ncia
    const { data: aiAgent, error: agentError } = await supabase
      .from('ai_whatsapp_agents')
      .select('*')
      .eq('evolution_config_id', configId)
      .eq('is_active', true)
      .eq('auto_response', true)
      .single();

    if (agentError || !aiAgent) {
      console.log('‚ÑπÔ∏è PASSO 2: Nenhum agente de IA ativo encontrado. Finalizando auto-resposta.', { agentError });
      return;
    }
    console.log(`ü§ñ PASSO 2: Agente de IA encontrado: ${aiAgent.id}`);

    // Buscar o hist√≥rico da conversa para dar contexto
    console.log('üìö PASSO 3: Buscando hist√≥rico da conversa...');
    const { data: previousMessages, error: historyError } = await supabase
      .from('whatsapp_messages')
      .select('content, sender_type')
      .eq('conversation_id', conversationId)
      .order('timestamp', { ascending: false })
      .limit(10);

    if (historyError) {
      console.error('‚ùå Erro no PASSO 3 ao buscar hist√≥rico:', historyError);
    }
    console.log(`üìö PASSO 3: Hist√≥rico encontrado: ${previousMessages?.length || 0} mensagens.`);
    
    // Montar o corpo da requisi√ß√£o para a fun√ß√£o de IA
    const invokeBody = {
      agentId: aiAgent.id,
      userMessage: messageContent,
      previousMessages: previousMessages || [],
      systemPrompt: aiAgent.system_prompt,
      model: aiAgent.model,
      openaiApiKey: aiAgent.openai_api_key,
    };

    // Invocar a fun√ß√£o de IA para gerar a resposta
    console.log('üöÄ PASSO 4: Invocando a fun√ß√£o generate-ai-response...');
    const { data: aiFunctionResponse, error: aiFunctionError } = await supabase.functions.invoke('openai-handler', {
      body: {
        // ##############################################
        // ### ADICIONE A ACTION AQUI                 ###
        // ##############################################
        action: 'generate', // Especifica que queremos gerar texto
        agentId: aiAgent.id,
        userMessage: messageContent,
        previousMessages: previousMessages || [],
        systemPrompt: aiAgent.system_prompt,
        model: aiAgent.model,
        openaiApiKey: aiAgent.openai_api_key,
      }
    });

    if (aiFunctionError) {
      console.error('‚ùå Erro no PASSO 4 ao invocar a fun√ß√£o de IA:', aiFunctionError);
      throw new Error(`Erro ao invocar a fun√ß√£o de IA: ${aiFunctionError.message}`);
    }
    console.log('‚úÖ PASSO 4: Fun√ß√£o de IA invocada com sucesso.');

    const { aiResponse, tokensUsed, modelUsed } = aiFunctionResponse;
    
    if (!aiResponse) {
      console.error('‚ùå Erro no PASSO 5: A fun√ß√£o de IA n√£o retornou uma resposta v√°lida.');
      throw new Error("A fun√ß√£o de IA n√£o retornou uma resposta v√°lida.");
    }
    console.log('‚úÖ PASSO 5: Resposta da IA recebida:', aiResponse.substring(0, 50) + "...");

    // Salvar o log da intera√ß√£o com a IA
    console.log('üíæ PASSO 6: Salvando log da intera√ß√£o...');
    const { error: logInsertError } = await supabase.from('ai_interaction_logs').insert({
      agent_id: aiAgent.id,
      conversation_id: conversationId,
      user_message: messageContent,
      ai_response: aiResponse,
      tokens_used: tokensUsed,
      model_used: modelUsed
    });

    if (logInsertError) {
      console.error('‚ùå Erro no PASSO 6 ao salvar log:', logInsertError);
    } else {
      console.log('‚úÖ PASSO 6: Log da intera√ß√£o salvo com sucesso.');
    }

    // Buscar o n√∫mero de telefone para enviar a resposta
    console.log('üìû PASSO 7: Buscando n√∫mero do contato...');
    const { data: conversationData, error: conversationError } = await supabase
        .from('whatsapp_conversations')
        .select('contact_number')
        .eq('id', conversationId)
        .single();

    if (conversationError || !conversationData?.contact_number) {
        console.error('‚ùå Erro no PASSO 7 ao buscar n√∫mero do contato:', conversationError);
        throw new Error("N√£o foi poss√≠vel encontrar o n√∫mero do contato para responder.");
    }
    const contactNumber = conversationData.contact_number;
    console.log(`üìû PASSO 7: N√∫mero do contato encontrado: ${contactNumber}`);

    // Invocar o api-manager para ENVIAR a resposta para o WhatsApp
    console.log('üì§ PASSO 8: Invocando evolution-api-manager para enviar a resposta...');
    const { error: sendMessageError } = await supabase.functions.invoke('evolution-api-manager', {
      body: {
        action: 'send_message',
        config_id: configId,
        phone_number: contactNumber,
        message: aiResponse
      }
    });

    if (sendMessageError) {
      console.error('‚ùå Erro no PASSO 8 ao invocar o envio de mensagem:', sendMessageError);
      throw new Error(`Erro ao enviar mensagem de resposta: ${sendMessageError.message}`);
    }

    console.log('‚úÖ PASSO 8: Resposta da IA enviada com sucesso para o usu√°rio.');

  } catch (error) {
    console.error('‚ùå Erro GERAL no fluxo de auto-resposta da IA:', error);
  }
}
async function notifyConnectionSuccess(supabase, config) {
  console.log('üéâ Notifying connection success for config:', config.id);
  const { error: agentError } = await supabase.from('ai_whatsapp_agents').update({
    is_active: true,
    updated_at: new Date().toISOString()
  }).eq('evolution_config_id', config.id);
  if (agentError) {
    console.error('‚ùå Error updating related agents:', agentError);
  } else {
    console.log('‚úÖ Related agents updated successfully');
  }
}
